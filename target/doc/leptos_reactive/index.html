<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The reactive system for the Leptos Web framework."><title>leptos_reactive - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="leptos_reactive" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.0-nightly (9ecda8de8 2023-04-30)" data-search-js="search-618e954b235f6acc.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-6f6ffb5395b17c6e.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../leptos_reactive/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../leptos_reactive/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate leptos_reactive</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.3.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">leptos_reactive</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/leptos_reactive/lib.rs.html#1-143">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The reactive system for the <a href="https://docs.rs/leptos/latest/leptos/">Leptos</a> Web framework.</p>
<h3 id="fine-grained-reactivity"><a href="#fine-grained-reactivity">Fine-Grained Reactivity</a></h3>
<p>Leptos is built on a fine-grained reactive system, which means that individual reactive values
(“signals,” sometimes known as observables) trigger the code that reacts to them (“effects,”
sometimes known as observers) to re-run. These two halves of the reactive system are inter-dependent.
Without effects, signals can change within the reactive system but never be observed in a way
that interacts with the outside world. Without signals, effects run once but never again, as
there’s no observable value to subscribe to.</p>
<p>Here are the most commonly-used functions and types you’ll need to build a reactive system:</p>
<h4 id="signals"><a href="#signals">Signals</a></h4>
<ol>
<li><em>Signals:</em> <a href="signal_prelude/fn.create_signal.html" title="fn leptos_reactive::signal_prelude::create_signal"><code>create_signal</code></a>, which returns a (<a href="signal_prelude/struct.ReadSignal.html" title="struct leptos_reactive::signal_prelude::ReadSignal"><code>ReadSignal</code></a>,
<a href="signal_prelude/struct.WriteSignal.html" title="struct leptos_reactive::signal_prelude::WriteSignal"><code>WriteSignal</code></a>) tuple, or <a href="signal_prelude/fn.create_rw_signal.html" title="fn leptos_reactive::signal_prelude::create_rw_signal"><code>create_rw_signal</code></a>, which returns
a signal <a href="signal_prelude/struct.RwSignal.html" title="struct leptos_reactive::signal_prelude::RwSignal"><code>RwSignal</code></a> without this read-write segregation.</li>
<li><em>Derived Signals:</em> any function that relies on another signal.</li>
<li><em>Memos:</em> <a href="signal_prelude/prelude/fn.create_memo.html" title="fn leptos_reactive::signal_prelude::prelude::create_memo"><code>create_memo</code></a>, which returns a <a href="signal_prelude/prelude/struct.Memo.html" title="struct leptos_reactive::signal_prelude::prelude::Memo"><code>Memo</code></a>.</li>
<li><em>Resources:</em> <a href="fn.create_resource.html" title="fn leptos_reactive::create_resource"><code>create_resource</code></a>, which converts an <code>async</code> <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> into a
synchronous <a href="struct.Resource.html" title="struct leptos_reactive::Resource"><code>Resource</code></a> signal.</li>
<li><em>Triggers:</em> <a href="fn.create_trigger.html" title="fn leptos_reactive::create_trigger"><code>create_trigger</code></a>, creates a purely reactive <a href="struct.Trigger.html" title="struct leptos_reactive::Trigger"><code>Trigger</code></a> primitive without any associated state.</li>
</ol>
<h4 id="effects"><a href="#effects">Effects</a></h4>
<ol>
<li>Use <a href="fn.create_effect.html" title="fn leptos_reactive::create_effect"><code>create_effect</code></a> when you need to synchronize the reactive system
with something outside it (for example: logging to the console, writing to a file or local storage)</li>
<li>The Leptos DOM renderer wraps any <a href="https://doc.rust-lang.org/nightly/core/ops/function/trait.Fn.html" title="trait core::ops::function::Fn"><code>Fn</code></a> in your template with <a href="fn.create_effect.html" title="fn leptos_reactive::create_effect"><code>create_effect</code></a>, so
components you write do <em>not</em> need explicit effects to synchronize with the DOM.</li>
</ol>
<h4 id="example"><a href="#example">Example</a></h4>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>leptos_reactive::<span class="kw-2">*</span>;

<span class="comment">// creates a new reactive Scope
// this is omitted from most of the examples in the docs
// you usually won&#39;t need to call it yourself
</span>create_scope(create_runtime(), |cx| {
    <span class="comment">// a signal: returns a (getter, setter) pair
    </span><span class="kw">let </span>(count, set_count) = create_signal(cx, <span class="number">0</span>);

    <span class="comment">// calling the getter gets the value
    </span><span class="macro">assert_eq!</span>(count(), <span class="number">0</span>);
    <span class="comment">// calling the setter sets the value
    </span>set_count(<span class="number">1</span>);
    <span class="comment">// or we can mutate it in place with update()
    </span>set_count.update(|n| <span class="kw-2">*</span>n += <span class="number">1</span>);

    <span class="comment">// a derived signal: a plain closure that relies on the signal
    // the closure will run whenever we *access* double_count()
    </span><span class="kw">let </span>double_count = <span class="kw">move </span>|| count() * <span class="number">2</span>;
    <span class="macro">assert_eq!</span>(double_count(), <span class="number">4</span>);

    <span class="comment">// a memo: subscribes to the signal
    // the closure will run only when count changes
    </span><span class="kw">let </span>memoized_triple_count = create_memo(cx, <span class="kw">move </span>|<span class="kw">_</span>| count() * <span class="number">3</span>);
    <span class="macro">assert_eq!</span>(memoized_triple_count(), <span class="number">6</span>);

    <span class="comment">// this effect will run whenever count() changes
    </span>create_effect(cx, <span class="kw">move </span>|<span class="kw">_</span>| {
        <span class="macro">println!</span>(<span class="string">&quot;Count = {}&quot;</span>, count());
    });
});</code></pre></div>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.GlobalSuspenseContext"><code>pub use suspense::<a class="struct" href="suspense/struct.GlobalSuspenseContext.html" title="struct leptos_reactive::suspense::GlobalSuspenseContext">GlobalSuspenseContext</a>;</code></div></li><li><div class="item-name" id="reexport.SuspenseContext"><code>pub use suspense::<a class="struct" href="suspense/struct.SuspenseContext.html" title="struct leptos_reactive::suspense::SuspenseContext">SuspenseContext</a>;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="prelude/index.html" title="mod leptos_reactive::prelude">prelude</a></div><div class="desc docblock-short">This prelude imports all signal types as well as all signal
traits needed to use those types.</div></li><li><div class="item-name"><a class="mod" href="signal_prelude/index.html" title="mod leptos_reactive::signal_prelude">signal_prelude</a></div><div class="desc docblock-short">This prelude imports all signal types as well as all signal
traits needed to use those types.</div></li><li><div class="item-name"><a class="mod" href="suspense/index.html" title="mod leptos_reactive::suspense">suspense</a></div><div class="desc docblock-short">Types that handle asynchronous data loading via <code>&lt;Suspense/&gt;</code>.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Memo.html" title="struct leptos_reactive::Memo">Memo</a></div><div class="desc docblock-short">An efficient derived reactive value based on other reactive values.</div></li><li><div class="item-name"><a class="struct" href="struct.ReadSignal.html" title="struct leptos_reactive::ReadSignal">ReadSignal</a></div><div class="desc docblock-short">The getter for a reactive signal.</div></li><li><div class="item-name"><a class="struct" href="struct.Resource.html" title="struct leptos_reactive::Resource">Resource</a></div><div class="desc docblock-short">A signal that reflects the
current state of an asynchronous task, allowing you to integrate <code>async</code>
<a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a>s into the synchronous reactive system.</div></li><li><div class="item-name"><a class="struct" href="struct.ResourceId.html" title="struct leptos_reactive::ResourceId">ResourceId</a></div><div class="desc docblock-short">Unique ID assigned to a <a href="struct.Resource.html" title="struct leptos_reactive::Resource"><code>Resource</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.RuntimeId.html" title="struct leptos_reactive::RuntimeId">RuntimeId</a></div><div class="desc docblock-short">Unique ID assigned to a Runtime.</div></li><li><div class="item-name"><a class="struct" href="struct.RwSignal.html" title="struct leptos_reactive::RwSignal">RwSignal</a></div><div class="desc docblock-short">A signal that combines the getter and setter into one value, rather than
separating them into a <a href="signal_prelude/struct.ReadSignal.html" title="struct leptos_reactive::signal_prelude::ReadSignal"><code>ReadSignal</code></a> and a <a href="signal_prelude/struct.WriteSignal.html" title="struct leptos_reactive::signal_prelude::WriteSignal"><code>WriteSignal</code></a>. You may prefer this
its style, or it may be easier to pass around in a context or as a function argument.</div></li><li><div class="item-name"><a class="struct" href="struct.Scope.html" title="struct leptos_reactive::Scope">Scope</a></div><div class="desc docblock-short">A Each scope can have
child scopes, and may in turn have a parent.</div></li><li><div class="item-name"><a class="struct" href="struct.ScopeDisposer.html" title="struct leptos_reactive::ScopeDisposer">ScopeDisposer</a></div><div class="desc docblock-short">Creating a <a href="struct.Scope.html" title="struct leptos_reactive::Scope"><code>Scope</code></a> gives you a disposer, which can be called
to dispose of that reactive scope.</div></li><li><div class="item-name"><a class="struct" href="struct.ScopeId.html" title="struct leptos_reactive::ScopeId">ScopeId</a></div><div class="desc docblock-short">Unique ID assigned to a <a href="struct.Scope.html" title="struct leptos_reactive::Scope"><code>Scope</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Signal.html" title="struct leptos_reactive::Signal">Signal</a></div><div class="desc docblock-short">A wrapper for any kind of readable reactive signal: a <a href="signal_prelude/struct.ReadSignal.html" title="struct leptos_reactive::signal_prelude::ReadSignal"><code>ReadSignal</code></a>,
<a href="signal_prelude/prelude/struct.Memo.html" title="struct leptos_reactive::signal_prelude::prelude::Memo"><code>Memo</code></a>, <a href="signal_prelude/struct.RwSignal.html" title="struct leptos_reactive::signal_prelude::RwSignal"><code>RwSignal</code></a>, or derived signal closure.</div></li><li><div class="item-name"><a class="struct" href="struct.SignalSetter.html" title="struct leptos_reactive::SignalSetter">SignalSetter</a></div><div class="desc docblock-short">A wrapper for any kind of settable reactive signal: a <a href="signal_prelude/struct.WriteSignal.html" title="struct leptos_reactive::signal_prelude::WriteSignal"><code>WriteSignal</code></a>,
<a href="signal_prelude/struct.RwSignal.html" title="struct leptos_reactive::signal_prelude::RwSignal"><code>RwSignal</code></a>, or closure that receives a value and sets a signal depending
on it.</div></li><li><div class="item-name"><a class="struct" href="struct.StoredValue.html" title="struct leptos_reactive::StoredValue">StoredValue</a></div><div class="desc docblock-short">A <strong>non-reactive</strong> wrapper for any value, which can be created with <a href="fn.store_value.html" title="fn leptos_reactive::store_value"><code>store_value</code></a>.</div></li><li><div class="item-name"><a class="struct" href="struct.Trigger.html" title="struct leptos_reactive::Trigger">Trigger</a></div><div class="desc docblock-short">Reactive Trigger, notifies reactive code to rerun.</div></li><li><div class="item-name"><a class="struct" href="struct.WriteSignal.html" title="struct leptos_reactive::WriteSignal">WriteSignal</a></div><div class="desc docblock-short">The setter for a reactive signal.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.MaybeSignal.html" title="enum leptos_reactive::MaybeSignal">MaybeSignal</a></div><div class="desc docblock-short">A wrapper for a value that is <em>either</em> <code>T</code> or <a href="signal_prelude/prelude/struct.Signal.html" title="struct leptos_reactive::signal_prelude::prelude::Signal"><code>Signal&lt;T&gt;</code></a>.</div></li><li><div class="item-name"><a class="enum" href="enum.SerializationError.html" title="enum leptos_reactive::SerializationError">SerializationError</a></div><div class="desc docblock-short">Describes errors that can occur while serializing and deserializing data,
typically during the process of streaming <a href="struct.Resource.html" title="struct leptos_reactive::Resource"><code>Resource</code></a>s from
the server to the client.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.IntoSignal.html" title="trait leptos_reactive::IntoSignal">IntoSignal</a></div><div class="desc docblock-short">Helper trait for converting <code>Fn() -&gt; T</code> closures into
<a href="signal_prelude/prelude/struct.Signal.html" title="struct leptos_reactive::signal_prelude::prelude::Signal"><code>Signal&lt;T&gt;</code></a>.</div></li><li><div class="item-name"><a class="trait" href="trait.IntoSignalSetter.html" title="trait leptos_reactive::IntoSignalSetter">IntoSignalSetter</a></div><div class="desc docblock-short">Helper trait for converting <code>Fn(T)</code> into <a href="signal_prelude/prelude/struct.SignalSetter.html" title="struct leptos_reactive::signal_prelude::prelude::SignalSetter"><code>SignalSetter&lt;T&gt;</code></a>.</div></li><li><div class="item-name"><a class="trait" href="trait.Serializable.html" title="trait leptos_reactive::Serializable">Serializable</a></div><div class="desc docblock-short">Describes an object that can be serialized to or from a supported format
Currently those are JSON and Cbor</div></li><li><div class="item-name"><a class="trait" href="trait.SignalDispose.html" title="trait leptos_reactive::SignalDispose">SignalDispose</a></div><div class="desc docblock-short">This trait allows disposing a signal before its <a href="struct.Scope.html" title="struct leptos_reactive::Scope"><code>Scope</code></a> has been disposed.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalGet.html" title="trait leptos_reactive::SignalGet">SignalGet</a></div><div class="desc docblock-short">This trait allows getting an owned value of the signals
inner type.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalGetUntracked.html" title="trait leptos_reactive::SignalGetUntracked">SignalGetUntracked</a></div><div class="desc docblock-short">Trait implemented for all signal types which you can <code>get</code> a value
from, such as <a href="signal_prelude/struct.ReadSignal.html" title="struct leptos_reactive::signal_prelude::ReadSignal"><code>ReadSignal</code></a>,
<a href="signal_prelude/prelude/struct.Memo.html" title="struct leptos_reactive::signal_prelude::prelude::Memo"><code>Memo</code></a>, etc., which allows getting the inner value without
subscribing to the current scope.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalSet.html" title="trait leptos_reactive::SignalSet">SignalSet</a></div><div class="desc docblock-short">This trait allows setting the value of a signal.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalSetUntracked.html" title="trait leptos_reactive::SignalSetUntracked">SignalSetUntracked</a></div><div class="desc docblock-short">Trait implemented for all signal types which you can <code>set</code> the inner
value, such as <a href="signal_prelude/struct.WriteSignal.html" title="struct leptos_reactive::signal_prelude::WriteSignal"><code>WriteSignal</code></a> and <a href="signal_prelude/struct.RwSignal.html" title="struct leptos_reactive::signal_prelude::RwSignal"><code>RwSignal</code></a>, which allows setting
the inner value without causing effects which depend on the signal
from being run.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalStream.html" title="trait leptos_reactive::SignalStream">SignalStream</a></div><div class="desc docblock-short">This trait allows converting a signal into a async <a href="../futures_core/stream/trait.Stream.html" title="trait futures_core::stream::Stream"><code>Stream</code></a>.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalUpdate.html" title="trait leptos_reactive::SignalUpdate">SignalUpdate</a></div><div class="desc docblock-short">This trait allows updating the inner value of a signal.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalUpdateUntracked.html" title="trait leptos_reactive::SignalUpdateUntracked">SignalUpdateUntracked</a></div><div class="desc docblock-short">This trait allows updating the signals value without causing
dependant effects to run.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalWith.html" title="trait leptos_reactive::SignalWith">SignalWith</a></div><div class="desc docblock-short">This trait allows obtaining an immutable reference to the signal’s
inner type.</div></li><li><div class="item-name"><a class="trait" href="trait.SignalWithUntracked.html" title="trait leptos_reactive::SignalWithUntracked">SignalWithUntracked</a></div><div class="desc docblock-short">This trait allows getting a reference to the signals inner value
without creating a dependency on the signal.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.create_blocking_resource.html" title="fn leptos_reactive::create_blocking_resource">create_blocking_resource</a></div><div class="desc docblock-short">Creates a “blocking” <a href="struct.Resource.html" title="struct leptos_reactive::Resource"><code>Resource</code></a>. When server-side rendering is used,
this resource will cause any <code>&lt;Suspense/&gt;</code> you read it under to block the initial
chunk of HTML from being sent to the client. This means that if you set things like
HTTP headers or <code>&lt;head&gt;</code> metadata in that <code>&lt;Suspense/&gt;</code>, that header material will
be included in the server’s original response.</div></li><li><div class="item-name"><a class="fn" href="fn.create_effect.html" title="fn leptos_reactive::create_effect">create_effect</a></div><div class="desc docblock-short">Effects run a certain chunk of code whenever the signals they depend on change.
<code>create_effect</code> immediately runs the given function once, tracks its dependence
on any signal values read within it, and reruns the function whenever the value
of a dependency changes.</div></li><li><div class="item-name"><a class="fn" href="fn.create_isomorphic_effect.html" title="fn leptos_reactive::create_isomorphic_effect">create_isomorphic_effect</a></div><div class="desc docblock-short">Creates an effect; unlike effects created by <a href="fn.create_effect.html" title="fn leptos_reactive::create_effect"><code>create_effect</code></a>, isomorphic effects will run on
the server as well as the client.</div></li><li><div class="item-name"><a class="fn" href="fn.create_local_resource.html" title="fn leptos_reactive::create_local_resource">create_local_resource</a></div><div class="desc docblock-short">Creates a <em>local</em> <a href="struct.Resource.html" title="struct leptos_reactive::Resource"><code>Resource</code></a>, which is a signal that
reflects the current state of an asynchronous task, allowing you to
integrate <code>async</code> <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a>s into the synchronous reactive system.</div></li><li><div class="item-name"><a class="fn" href="fn.create_local_resource_with_initial_value.html" title="fn leptos_reactive::create_local_resource_with_initial_value">create_local_resource_with_initial_value</a></div><div class="desc docblock-short">Creates a <em>local</em> <a href="struct.Resource.html" title="struct leptos_reactive::Resource"><code>Resource</code></a> with the given initial value,
which will only generate and run a <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> using the <code>fetcher</code> when the
<code>source</code> changes.</div></li><li><div class="item-name"><a class="fn" href="fn.create_many_signals.html" title="fn leptos_reactive::create_many_signals">create_many_signals</a></div><div class="desc docblock-short">Works exactly as <a href="signal_prelude/fn.create_signal.html" title="fn leptos_reactive::signal_prelude::create_signal"><code>create_signal</code></a>, but creates multiple signals at once.</div></li><li><div class="item-name"><a class="fn" href="fn.create_many_signals_mapped.html" title="fn leptos_reactive::create_many_signals_mapped">create_many_signals_mapped</a></div><div class="desc docblock-short">Works exactly as <a href="signal_prelude/fn.create_many_signals.html" title="fn leptos_reactive::signal_prelude::create_many_signals"><code>create_many_signals</code></a>, but applies the map function to each signal pair.</div></li><li><div class="item-name"><a class="fn" href="fn.create_memo.html" title="fn leptos_reactive::create_memo">create_memo</a></div><div class="desc docblock-short">Creates an efficient derived reactive value based on other reactive values.</div></li><li><div class="item-name"><a class="fn" href="fn.create_read_slice.html" title="fn leptos_reactive::create_read_slice">create_read_slice</a></div><div class="desc docblock-short">Takes a memoized, read-only slice of a signal. This is equivalent to the
read-only half of <a href="fn.create_slice.html" title="fn leptos_reactive::create_slice"><code>create_slice</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.create_resource.html" title="fn leptos_reactive::create_resource">create_resource</a></div><div class="desc docblock-short">Creates a <a href="struct.Resource.html" title="struct leptos_reactive::Resource"><code>Resource</code></a>, which is a signal that reflects the
current state of an asynchronous task, allowing you to integrate <code>async</code>
<a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a>s into the synchronous reactive system.</div></li><li><div class="item-name"><a class="fn" href="fn.create_resource_with_initial_value.html" title="fn leptos_reactive::create_resource_with_initial_value">create_resource_with_initial_value</a></div><div class="desc docblock-short">Creates a <a href="struct.Resource.html" title="struct leptos_reactive::Resource"><code>Resource</code></a> with the given initial value, which
will only generate and run a <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> using the <code>fetcher</code> when the <code>source</code> changes.</div></li><li><div class="item-name"><a class="fn" href="fn.create_rw_signal.html" title="fn leptos_reactive::create_rw_signal">create_rw_signal</a></div><div class="desc docblock-short">Creates a reactive signal with the getter and setter unified in one value.
You may prefer this style, or it may be easier to pass around in a context
or as a function argument.</div></li><li><div class="item-name"><a class="fn" href="fn.create_selector.html" title="fn leptos_reactive::create_selector">create_selector</a></div><div class="desc docblock-short">Creates a conditional signal that only notifies subscribers when a change
in the source signal’s value changes whether it is equal to the key value
(as determined by <a href="https://doc.rust-lang.org/nightly/core/cmp/trait.PartialEq.html" title="trait core::cmp::PartialEq"><code>PartialEq</code></a>.)</div></li><li><div class="item-name"><a class="fn" href="fn.create_selector_with_fn.html" title="fn leptos_reactive::create_selector_with_fn">create_selector_with_fn</a></div><div class="desc docblock-short">Creates a conditional signal that only notifies subscribers when a change
in the source signal’s value changes whether the given function is true.</div></li><li><div class="item-name"><a class="fn" href="fn.create_signal.html" title="fn leptos_reactive::create_signal">create_signal</a></div><div class="desc docblock-short">Creates a signal, the basic reactive primitive.</div></li><li><div class="item-name"><a class="fn" href="fn.create_signal_from_stream.html" title="fn leptos_reactive::create_signal_from_stream">create_signal_from_stream</a></div><div class="desc docblock-short">Creates a signal that always contains the most recent value emitted by a
<a href="../futures_core/stream/trait.Stream.html" title="trait futures_core::stream::Stream"><code>Stream</code></a>.
If the stream has not yet emitted a value since the signal was created, the signal’s
value will be <code>None</code>.</div></li><li><div class="item-name"><a class="fn" href="fn.create_slice.html" title="fn leptos_reactive::create_slice">create_slice</a></div><div class="desc docblock-short">Derives a reactive slice of an <a href="signal_prelude/struct.RwSignal.html" title="struct leptos_reactive::signal_prelude::RwSignal"><code>RwSignal</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.create_trigger.html" title="fn leptos_reactive::create_trigger">create_trigger</a></div><div class="desc docblock-short">Creates a <a href="struct.Trigger.html" title="struct leptos_reactive::Trigger"><code>Trigger</code></a>, a kind of reactive primitive.</div></li><li><div class="item-name"><a class="fn" href="fn.create_write_slice.html" title="fn leptos_reactive::create_write_slice">create_write_slice</a></div><div class="desc docblock-short">Creates a setter to access one slice of a signal. This is equivalent to the
write-only half of <a href="fn.create_slice.html" title="fn leptos_reactive::create_slice"><code>create_slice</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.expect_context.html" title="fn leptos_reactive::expect_context">expect_context</a></div><div class="desc docblock-short">Extracts a context value of type <code>T</code> from the reactive system by traversing
it upwards, beginning from the current <a href="struct.Scope.html" title="struct leptos_reactive::Scope">Scope</a> and iterating
through its parents, if any. The context value should have been provided elsewhere
using <a href="fn.provide_context.html" title="fn leptos_reactive::provide_context">provide_context</a>.</div></li><li><div class="item-name"><a class="fn" href="fn.on_cleanup.html" title="fn leptos_reactive::on_cleanup">on_cleanup</a></div><div class="desc docblock-short">Creates a cleanup function, which will be run when a <a href="struct.Scope.html" title="struct leptos_reactive::Scope"><code>Scope</code></a> is disposed.</div></li><li><div class="item-name"><a class="fn" href="fn.provide_context.html" title="fn leptos_reactive::provide_context">provide_context</a></div><div class="desc docblock-short">Provides a context value of type <code>T</code> to the current reactive <a href="struct.Scope.html" title="struct leptos_reactive::Scope"><code>Scope</code></a>
and all of its descendants. This can be consumed using <a href="fn.use_context.html" title="fn leptos_reactive::use_context"><code>use_context</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.queue_microtask.html" title="fn leptos_reactive::queue_microtask">queue_microtask</a></div><div class="desc docblock-short">The microtask is a short function which will run after the current task has
completed its work and when there is no other code waiting to be run before
control of the execution context is returned to the browser’s event loop.</div></li><li><div class="item-name"><a class="fn" href="fn.spawn_local.html" title="fn leptos_reactive::spawn_local">spawn_local</a></div><div class="desc docblock-short">Spawns and runs a thread-local <a href="https://doc.rust-lang.org/nightly/core/future/future/trait.Future.html" title="trait core::future::future::Future"><code>Future</code></a> in a platform-independent way.</div></li><li><div class="item-name"><a class="fn" href="fn.store_value.html" title="fn leptos_reactive::store_value">store_value</a></div><div class="desc docblock-short">Creates a <strong>non-reactive</strong> wrapper for any value by storing it within
the reactive system.</div></li><li><div class="item-name"><a class="fn" href="fn.use_context.html" title="fn leptos_reactive::use_context">use_context</a></div><div class="desc docblock-short">Extracts a context value of type <code>T</code> from the reactive system by traversing
it upwards, beginning from the current <a href="struct.Scope.html" title="struct leptos_reactive::Scope"><code>Scope</code></a> and iterating
through its parents, if any. The context value should have been provided elsewhere
using <a href="fn.provide_context.html" title="fn leptos_reactive::provide_context"><code>provide_context</code></a>.</div></li></ul></section></div></main></body></html>