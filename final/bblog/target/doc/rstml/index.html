<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Rust templating for XML-based formats (HTML, SVG, MathML) implemented on top of [`proc-macro::TokenStream`]s. Similar to JSX but for Rust (commonly named RSX). The parsed result is a nested `Node` structure, similar to the browser DOM, where node name and value are syn expressions to support building proc macros."><title>rstml - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-ba5701c5741a7b69.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="rstml" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.0-nightly (9ecda8de8 2023-04-30)" data-search-js="search-618e954b235f6acc.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-6f6ffb5395b17c6e.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../rstml/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../rstml/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate rstml</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.10.6</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">rstml</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/rstml/lib.rs.html#1-272">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Rust templating for XML-based formats (HTML, SVG, MathML) implemented on top
of [<code>proc-macro::TokenStream</code>]s. Similar to JSX but for Rust (commonly named
RSX). The parsed result is a nested <a href="enum.Node.html"><code>Node</code></a> structure, similar to the
browser DOM, where node name and value are syn expressions to support
building proc macros.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>std::convert::TryFrom;

<span class="kw">use </span>eyre::bail;
<span class="kw">use </span>quote::quote;
<span class="kw">use </span>rstml::{
    node::{Node, NodeAttribute, NodeElement, NodeText},
    parse2,
};

<span class="comment">// Create HTML `TokenStream`.
</span><span class="kw">let </span>tokens = <span class="macro">quote! </span>{ &lt;hello world&gt;<span class="string">&quot;hi&quot;</span>&lt;/hello&gt; };

<span class="comment">// Parse the tokens into a tree of `Node`s.
</span><span class="kw">let </span>nodes = parse2(tokens)<span class="question-mark">?</span>;

<span class="comment">// Extract some specific nodes from the tree.
</span><span class="kw">let </span>Node::Element(element) = <span class="kw-2">&amp;</span>nodes[<span class="number">0</span>] <span class="kw">else </span>{ <span class="macro">bail!</span>(<span class="string">&quot;element&quot;</span>) };
<span class="kw">let </span>NodeAttribute::Attribute(attribute) = <span class="kw-2">&amp;</span>element.attributes()[<span class="number">0</span>] <span class="kw">else </span>{ <span class="macro">bail!</span>(<span class="string">&quot;attribute&quot;</span>) };
<span class="kw">let </span>Node::Text(text) = <span class="kw-2">&amp;</span>element.children[<span class="number">0</span>] <span class="kw">else </span>{ <span class="macro">bail!</span>(<span class="string">&quot;text&quot;</span>) };

<span class="comment">// Work with the nodes.
</span><span class="macro">assert_eq!</span>(element.name().to_string(), <span class="string">&quot;hello&quot;</span>);
<span class="macro">assert_eq!</span>(attribute.key.to_string(), <span class="string">&quot;world&quot;</span>);
<span class="macro">assert_eq!</span>(text.value_string(), <span class="string">&quot;hi&quot;</span>);</code></pre></div>
<p>You might want to check out the <a href="https://github.com/stoically/syn-rsx/tree/main/examples/html-to-string-macro">html-to-string-macro example</a> as well.</p>
<h3 id="features"><a href="#features">Features</a></h3>
<ul>
<li>
<p><strong>Not opinionated</strong></p>
<p>Every tag or attribute name is valid</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>&lt;hello world /&gt;</code></pre></div>
</li>
<li>
<p><strong>Text nodes</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>&lt;div&gt;<span class="string">&quot;String literal&quot;</span>&lt;/div&gt;</code></pre></div>
</li>
<li>
<p><strong>Unquoted text nodes</strong></p>
</li>
</ul>
<p>Unquoted text is supported with few limitations:</p>
<ul>
<li>Only valid Rust TokenStream can be unquoted text (no single quote text is
supported, no unclosed braces, etc.)</li>
<li>Unquoted text not always can save spaces. It uses <a href="https://doc.rust-lang.org/proc_macro/struct.Span.html#method.source_text"><code>Span::source_text</code></a>
and <a href="https://doc.rust-lang.org/proc_macro/struct.Span.html#method.join"><code>Span::join</code></a> to retrive info about spaces, and it is not always
available.</li>
<li>Quoted text near unquoted treated as diferent Node, end library user
should decide whenever to preserve quotation.</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> 
   &lt;div&gt; <span class="prelude-val">Some </span>string that is valid rust token stream &lt;/div&gt;</code></pre></div>
<ul>
<li>
<p><strong>Node names separated by dash, colon or double colon</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>&lt;tag-name some:attribute-key=<span class="string">&quot;value&quot; </span>/&gt;
&lt;tag::name attribute::key=<span class="string">&quot;value&quot; </span>/&gt;</code></pre></div>
</li>
<li>
<p><strong>Node names with reserved keywords</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>&lt;input <span class="kw">type</span>=<span class="string">&quot;submit&quot; </span>/&gt;</code></pre></div>
</li>
<li>
<p><strong>Doctypes, Comments and Fragments</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>&lt;!DOCTYPE html&gt;
&lt;!-- <span class="string">&quot;comment&quot; </span>--&gt;
&lt;&gt;&lt;/&gt;</code></pre></div>
</li>
<li>
<p><strong>Braced blocks are parsed as arbitrary Rust code</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>&lt;{ <span class="kw">let </span>block = <span class="string">&quot;in node name position&quot;</span>; } /&gt;
&lt;div&gt;{ <span class="kw">let </span>block = <span class="string">&quot;in node position&quot;</span>; }&lt;/div&gt;
&lt;div { <span class="kw">let </span>block = <span class="string">&quot;in attribute position&quot;</span>; } /&gt;
&lt;div key={ <span class="kw">let </span>block = <span class="string">&quot;in attribute value position&quot;</span>; } /&gt;</code></pre></div>
</li>
<li>
<p><strong>Attribute values can be any valid syn expression without requiring
braces</strong></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>&lt;div key=some::value() /&gt;</code></pre></div>
</li>
<li>
<p><strong>Helpful error reporting out of the box</strong></p>
<div class="example-wrap"><pre class="language-no_build"><code>error: open tag has no corresponding close tag and is not self-closing
--&gt; examples/html-to-string-macro/tests/lib.rs:5:24
  |
5 |     html_to_string! { &lt;div&gt; };
  |                        ^^^
</code></pre></div></li>
<li>
<p><strong>Possibility to get the span for a whole node</strong></p>
</li>
</ul>
<p>This can be used to improve error reporting, e.g.</p>
<div class="example-wrap"><pre class="language-no_build"><code>error: Invalid element
--&gt; examples/src/main.rs:14:13
   |
14 | /             &lt;div&gt;
15 | |                 &quot;invalid node for some consumer specific reason&quot;
16 | |             &lt;/div&gt;
   | |__________________^
</code></pre></div>
<ul>
<li><strong>Recoverable parser</strong></li>
</ul>
<p>Can parse html with multiple mistakes.
As result library user get array of errors that can be reported, and tree of
nodes that was parsed.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code> &lt;div hello={world.} /&gt; &lt;!-- dot after world is invalid syn expression --&gt;
  &lt;&gt;
      &lt;div&gt;<span class="string">&quot;1&quot;</span>&lt;/x&gt; &lt;!-- incorrect closed tag --&gt;
      &lt;div&gt;<span class="string">&quot;2&quot;</span>&lt;/div&gt;
      &lt;div&gt;<span class="string">&quot;3&quot;</span>&lt;/div&gt;
      &lt;div {<span class="string">&quot;some-attribute-from-rust-block&quot;</span>}/&gt;
  &lt;/&gt;</code></pre></div>
<p>Using this feature one can write macro in IDE friendly way.
This macro will work faster (because on invalid syntax it change output
slightly, instead of removing it completely, so IDE can check diff quicly).
And give completion (goto definition, and other semantic related feature)
more often.</p>
<ul>
<li>
<p><strong>Customization</strong></p>
<p>A <a href="struct.ParserConfig.html"><code>ParserConfig</code></a> to customize parsing behavior is available, so if you
have   slightly different requirements for parsing and it’s not yet
customizable   feel free to open an issue or pull request to extend the
configuration.</p>
<p>One highlight with regards to customization is the <a href="struct.ParserConfig.html#method.transform_block"><code>transform_block</code></a>
configuration, which takes a closure that receives raw block content as
<code>ParseStream</code> and lets you optionally convert it to a <code>TokenStream</code>. That
makes it   possible to have custom syntax in blocks. More details in <a href="https://github.com/stoically/syn-rsx/issues/9">#9</a></p>
</li>
</ul>
</div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.atoms"><code>pub use node::<a class="mod" href="node/atoms/index.html" title="mod rstml::node::atoms">atoms</a>;</code></div></li></ul><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="node/index.html" title="mod rstml::node">node</a></div><div class="desc docblock-short">Tree of nodes.</div></li><li><div class="item-name"><a class="mod" href="recoverable/index.html" title="mod rstml::recoverable">recoverable</a></div><div class="desc docblock-short">Recoverable parser helper module. Contains trait and types that are using
during implementation of parsing with recovery after semantic errors.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Parser.html" title="struct rstml::Parser">Parser</a></div><div class="desc docblock-short">Primary library interface to RSX Parser</div></li><li><div class="item-name"><a class="struct" href="struct.ParserConfig.html" title="struct rstml::ParserConfig">ParserConfig</a></div><div class="desc docblock-short">Configures the <code>Parser</code> behavior</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum rstml::Error">Error</a></div></li><li><div class="item-name"><a class="enum" href="enum.ParsingResult.html" title="enum rstml::ParsingResult">ParsingResult</a></div><div class="desc docblock-short">Result of parsing.</div></li></ul><h2 id="functions" class="small-section-header"><a href="#functions">Functions</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.parse.html" title="fn rstml::parse">parse</a></div><div class="desc docblock-short">Parse the given <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>proc-macro::TokenStream</code></a> into a <a href="struct.Node.html"><code>Node</code></a> tree.</div></li><li><div class="item-name"><a class="fn" href="fn.parse2.html" title="fn rstml::parse2">parse2</a></div><div class="desc docblock-short">Parse the given <a href="https://docs.rs/proc-macro2/latest/proc_macro2/struct.TokenStream.html"><code>proc-macro2::TokenStream</code></a> into a <a href="struct.Node.html"><code>Node</code></a> tree.</div></li><li><div class="item-name"><a class="fn" href="fn.parse2_with_config.html" title="fn rstml::parse2_with_config">parse2_with_config</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">Parse the given <a href="https://docs.rs/proc-macro2/latest/proc_macro2/struct.TokenStream.html"><code>proc-macro2::TokenStream</code></a> into a <a href="struct.Node.html"><code>Node</code></a> tree with
custom <a href="struct.ParserConfig.html"><code>ParserConfig</code></a>.</div></li><li><div class="item-name"><a class="fn" href="fn.parse_with_config.html" title="fn rstml::parse_with_config">parse_with_config</a><span class="stab deprecated" title="">Deprecated</span></div><div class="desc docblock-short">Parse the given <a href="https://doc.rust-lang.org/proc_macro/struct.TokenStream.html"><code>proc-macro::TokenStream</code></a> into a <a href="struct.Node.html"><code>Node</code></a> tree with custom
<a href="struct.ParserConfig.html"><code>ParserConfig</code></a>.</div></li></ul></section></div></main></body></html>